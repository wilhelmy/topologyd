// This file contains code which assembles neighor information obtained by
// gathering "lldpcli neighbor" information in JSON format from all nodes into a
// graph. Currently unused.
package main

import (
	"log"
)

// A graph of all neighbor nodes identified by their MgmtIP (this).
// Invariant: neighbor nodes in neighbors[] should link back to this node in
// their neighbors[] member.
type NeighborGraph struct {
	this         string
	neighbors []*NeighborGraph
}

// Convenience data structure for mapping MgmtIP to the NeighborGraph starting
// from a given node.
type NeighborGraphs map[string]*NeighborGraph

func assemble_node(name string, node_neighbors *[]NeighborSource, graphs map[string]*NeighborGraph) *NeighborGraph {
    node := NeighborGraph { name, make([]*NeighborGraph, len(*node_neighbors)) }

    log.Println(graphs)
    //log.Printf("name: %s; neighbors: %+v, node_neighbors: %+v", name, neighbors, node_neighbors)

    // Loop over all neighbors found for this node, adding references to the
    // newly created struct to its neighbors but also adding references back
    // from its neighbors to this newly created node where necessary because it
    // didn't exist yet when its neighbors were allocated.
    for i, v := range *node_neighbors {
        // get neighbor's MgmtIP
        chassis, err := get_chassis(v.Iface.Chassis)
        if err != nil {
            log.Printf("Error: %s", err)
            continue
        }
        neighbor := get_mgmt_ip(&chassis)

        var seen_before bool
        node.neighbors[i], seen_before = graphs[neighbor]

        // neighbor was already initialized, link back to this node if such a ptr is missing
        if seen_before {
            // if the back reference already exists, exit early
            for _, vv := range graphs[neighbor].neighbors {
                if vv != nil && vv.this == name {goto outer_loop}
            }

            // find empty place in the slice to put the reference back to &node
            for j, vv := range graphs[neighbor].neighbors {
                if vv == nil {
                    graphs[neighbor].neighbors[j] = &node
                    goto outer_loop
                }
            }

            // XXX nothing append() couldn't fix but it shouldn't be there in the first place
            log.Printf("Warning: host %s: too many neighbors to add unexpected "+
                "reference to %s, possible bug.", neighbor, name)
        } else {
            // This node doesn't exist yet, which means it will be added later on. Skip for now.
        }
outer_loop:
    }

    return &node
}

// Takes a list of nodes generated by gather_neighbors_from_nodes and
// transforms them into a NeighborGraph, calling assemble_node on each node.
func assemble_graph(start string, neighbors *NodeMap) *NeighborGraphs {
    log.Println("assemble_graph")
    // Keep all nodes of the graph here for easy access
    graphs := make(NeighborGraphs, nodes_prealloc)
    log.Print("neighbors: ", neighbors)

    for k, v := range *neighbors {
        if v == nil {
            log.Printf("Error: neighbor '%s' has nil neighbors instead "+
                "of empty list. This is a bug.", k)
            continue
        }
        graphs[k] = assemble_node(k, v, graphs)
    }

    for k, v := range graphs {
        log.Println(k, v)
    }
    log.Println("end assemble_graph")

    return &graphs
}
