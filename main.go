/*
# Description

topologyd is a daemon for network discovery and monitoring for closed,
industrial ethernet networks consisting of Linux machines.

Its intended purpose is to discover the graph structure and state of
the network, which can be displayed to the user.

The user can configure a quiescent topology based on this graph, topologyd will
then monitor its neighbor nodes and report for example link failures or topology
mismatches such as swapped cables or unexpectedly changed hostnames or other
host information usually exchanged via LLDP.

# Features

topologyd is IPv6 ready and has been tested with link-local addressing.

It uses a HTTP REST API for communicating with other topologyd instances in the
network, all of which have to run on the same port. Other protocols involved are
LLDP for neighbor discovery, SNMP to read LLDP information from managed switches
on the network which are not running topologyd, NDP/ICMP to supplement
insufficient information obtained via SNMP.

# Dependencies

A machine running topologyd needs at the very least lldpd(8)/lldpcli(1) for LLDP
support. It also needs ping(8) and ip(8) for ICMP/NDP and mstpctl(8)/mstpd(8) in
case the network uses RSTP for link redundancy, in order to read out the port
state.

# Operation

topologyd is intended to be run on all machines on the network on the same port.

The REST API, topologyd's main interface, is documented in an OpenAPI document:
https://app.swaggerhub.com/apis-docs/wilhelmy/topologyd-open_api_3_0_0/0.1.0#/

During topology discovery (API endpoints /topology/graphviz and /topology/jgf)
topologyd contacts all nodes on the network to collect their LLDP neighbors on
the port used globally for topologyd on this network. If it cannot connect to a
machine, it assumes the host it tried to contact is a managed switch and falls
back to querying the LLDP neighbors via SNMP. topologyd then assembles the
network topology graph out of the information it received.

Such a graph in JGF format can then be defined as the quiescent topology (by
POST request to /topology/quiescent), for example, one can download the graph
from /topology/jgf, display it to the user in a secondary tool to allow for
modifications and then POST it to /topology/quiescent. If the request is sent
with propagation enabled, topologyd will distribute this topology to all nodes
listed in the graph.

In a monitoring cycle, topologyd will then poll its immediate neighbor nodes
defined in the quiescent topology in regular intervals and report mismatching
neighbors in three sets: quiescent, excess, missing and mismatching. Quiescent
nodes are nodes that are present as defined in the quiescent topology, excess
are ones that are present but not expected, missing are ones that are expected
but not present and mismatching ones are nodes where one ore more attributes
differ from what has been defined in the quiescent topology.

Currently topologyd prints the result of such monitoring cycles to stdout, other
methods for reporting can be added later by request.

Monitoring API endpoints are /topology/scan and /topology/status, which are
closely related to each other and the monitoring cycle described above. The
status endpoint is equivalent to performing a monitoring cycle and receiving
the result as JSON.

The scan endpoint is a propagating version of the status endpoint, which queries
the topology status from all nodes on the known parts of the network and returns
them all.

# Implementation decisions

 - Primary/suitable Management IP

   topologyd needs a way to identify remote hosts in a unique manner.
   Since topologyd uses LLDP, which supports multiple different identifier types
   for hosts (most commonly but not necessarily a MAC address of the host),
   it was decided that one or more of the IP addresses reported as MgmtIP via
   LLDP are "stable enough" to serve as that machine's primary identifier.
   topologyd sorts the MgmtIPs it receives and picks one according to policy of
   "prefer Link Local" and "prefer IPv6".

   In theory, lldpd knows the originating MAC address of an LLDP packet, but it
   currently does not expose this information over its external API.
   Furthermore, in topologyd's use case, IPv6 link-local (IPv6LL) addresses are
   usually generated by the EUI64 mechanism from MAC addresses, but those MAC
   addresses are not quite stable themselves on bridge interfaces, where they
   are randomly generated on first boot and then stored persistently (which
   means MAC addresses on the bridge interface can change between OS re-flashes
   of the same device).

   As such, it was decided to keep this "primary MgmtIP" as the unique host
   identifier for now, until a better idea or the need for one comes up.

 - mirror_mirror_on_the_wall

   This function saves topologyd a chassis data lookup from a host on the
   network by instead looking up that hosts's data from one of its neighbors,
   which has received it via LLDP.

   Currently there is no distinction between topologyd neighbors and SNMP
   neighbors, but this could be changed to prefer topologyd neighbors, as their
   information seems more accurate than that of most managed switches supporting
   SNMP.

 - Network hashcode

   This currently isn't implemented. It is meant as a unique hash for a
   quiescent topology JGF document, that is mandatory in order to define a
   topology and would need to be checked. It could perhaps be implemented as a
   simple SHA hash of the quiescent topology after sorting the JSON data and
   establishing some has whitespace rules. It could also be something else, or
   dropped entirely, since it was defined as a requirement for reasons that were
   a bit unclear.

 - STP

   topologyd was designed primarily with RSTP enabled networks in mind. The RSTP
   state is queried when requesting the network graph, and displayed in the
   graphviz output with different colors on network links.

   Currently, mstpd is used for this purpose and it's the only supported (R)STP
   implementation in mstpd-status.go. The output of the mstpctl commandline tool
   is parsed and formatted into an implementation independent format containing
   only interface names and STP link states, which should make it easy to switch
   to a different STP implementation.

 - lldpd JSON handling

   topologyd relies on a locally running lldpd for exchanging LLDP messages to
   neighoring hosts on the network. This is currently topologyd's main
   dependency which extends to two spots in the codebase.

   1. "lldpcli -f json" output is handled in lldpcli-json.go. This format is
   flattened for internal use to contain only generic LLDP information not in an
   lldpd specific format and could be changed in case another LLDP
   implementation is desirable later.

   2. the internal API endpoints /lldp/chassis and /lldp/neighbors are direct
   proxies for unmodified "lldpcli -f json show {chassis,neighbors}" output.

# Protocols

 - LLDP (lldpcli-json.go)

   LLDP is used to query link-level neighbors. An LLDP enabled node will send an
   "I'm here" packet containing machine information every few seconds, typically
   on all network interfaces, but only to its immediate neighbor nodes.

   Unmanaged switches will forward this packet on all ports, managed switches
   typically support LLDP themselves and will register the node as a neighbor in
   their internal table, including information such as when and on which
   interface the packet arrived, and discard the packet rather than forward it.

   LLDP neighbors are queried by topologyd either via topologyd's REST API or -
   failing that - an attempt is made to retrieve the neighbors via SNMP.

 - SNMP (snmp.go)

   SNMP is typically used for monitoring of managed switches and other network
   equipment. In topologyd's case, because topologyd cannot be installed on the
   managed switches on the network (the vendors won't let us, even if their
   switches are Linux based) it was deemed necessary to implement SNMP for this
   purpose.

   SNMP is a very old protocol (it predates HTTP!) based on ASN.1 and supports
   both TCP and UDP as its underlying transport protocols. Some switches only
   support either TCP or UDP, some only on IPv4 but not IPv6, some don't support
   it on IPv6LL (link local) despite announcing their IPv6LL address as the LLDP
   MgmtIP address.

   Despite having standardized fields in so called "Management Information Base"
   documents — one of which being the LLDP-MIB which specifies the datatypes and
   table formats for querying LLDP data from switches — every switch vendor
   implements SNMP differently and not always according to the specification.
   Depending on a switch vendor's quirks, additional tweaks need to be
   implemented in snmp.go.

   While testing different switches, it also turned out to be much slower to
   query data from switches via SNMP compared to topologyd's API. This is not
   necessarily due to SNMP being a slow protocol but rather a slow
   implementation on the switch vendor's side. That, and the complexity of
   wrangling SNMP OIDs to extract information, is why SNMP is the fallback
   solution after topologyd's REST API rather than the primary protocol for the
   discovery of the LLDP neighbors from remote hosts.

 - NDP/ICMP (ndp-icmp.go)

   topologyd supplements the data received via SNMP and LLDP by reading the
   kernel's NDP table. NDP is the IPv6 protocol which replaces IPv4's ARP/RARP.
   However, the table does not automatically contain all nodes on the network.

   In order to make nodes appear in the NDP table, it is necessary to establish
   communication with them. topologyd does this by sending ICMPv6 echo requests
   (ping) to the IPv6 multicast address for all nodes on the network, ff02::1.

   All nodes receiving this echo request respond with an echo response (unless
   they have ICMPv6 disabled), after which there is a mapping from MAC addresses
   to IP addresses in the NDP table. The echo response is thus handled by the
   kernel and not processed any further  by topologyd, as topologyd does not
   need any information from it.

# Copyright

© 2022-2024 Moritz Wilhelmy. All rights reserved.

topologyd is available under the GPL version 3 for the general public.

topologyd was written on a contractual basis, but the contract expired.
If you want to fund its further development, commercial support is available,
please inquire for details.

*/
package main

import (
	"topologyD"
)

// Wrapper around "topologyD.Main()" function which is required to work
// around godoc bug https://github.com/golang/go/issues/5727
// This entire "package" just calls the "real" main function so godoc can
// generate HTML documentation (it refuses to do so on the "main" package
// otherwise).
func main() {
	topologyD.Main()
}
